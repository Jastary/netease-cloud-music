### 网易云音乐项目（移动端）

------

[网易云API](https://binaryify.github.io/NeteaseCloudMusicApi/#/?id=neteasecloudmusicapi)

#### 脚手架新建vue项目

##### 新建项目

```
vue create netease-cloud-music
```

1）选择模式

<img src="%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E9%A1%B9%E7%9B%AE%EF%BC%88%E7%A7%BB%E5%8A%A8%E7%AB%AF%EF%BC%89.assets/image-20230320202436548.png" alt="image-20230320202436548" style="zoom:67%;" />

2）选择配置

注意取消选择生产校验

<img src="%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E9%A1%B9%E7%9B%AE%EF%BC%88%E7%A7%BB%E5%8A%A8%E7%AB%AF%EF%BC%89.assets/image-20230320202527369.png" alt="image-20230320202527369" style="zoom:67%;" />

3）选择版本

选择vue3版本

<img src="%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E9%A1%B9%E7%9B%AE%EF%BC%88%E7%A7%BB%E5%8A%A8%E7%AB%AF%EF%BC%89.assets/image-20230320202642421.png" alt="image-20230320202642421" style="zoom:67%;" />

4）选择生产模式&样式选择Less

<img src="%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E9%A1%B9%E7%9B%AE%EF%BC%88%E7%A7%BB%E5%8A%A8%E7%AB%AF%EF%BC%89.assets/image-20230320202756851.png" alt="image-20230320202756851" style="zoom:67%;" />

5）生成项目



##### 踩坑点

问题：命名冲突导致打包项目报错

```
Conflict: Multiple assets emit different content to the same filename index.html  
ERROR in Conflict: Multiple assets emit different content to the same filename index.html  
webpack compiled with 1 error
```

解决1：

* 修改public文件夹下面的index.html为app.html
* 修改node_modules/webpack/bin/webpack.js文件

```
//在该文件的头部添加
html: { template: './src/app.html' }
```

解决2：

更换文件的存放路径，路径中不能出现中文





#### 实现移动端适配

##### 适配的js文件

public/js文件夹下新建rem.js作为本项目的适配文件

```
function remSize() {
    //获取设备的宽度
    var deviceWidth = document.documentElement.clientWidth || window.innerWidth
    //控制设备的宽度：一般默认设计稿都是750px，如果超过就限制在750;也不能小于320
    if (deviceWidth >= 750) {
        deviceWidth = 750
    }
    if (deviceWidth <= 320) {
        deviceWidth = 320
    }

	 //设置字体大小
    //750px-->1rem=100px  375px--->1rem=50px
    document.documentElement.style.fontSize = (deviceWidth / 7.5) + 'px'
}
//适配
remSize()

//实现窗口发生变化实现移动端适配
window.onresize = function () {
    //当窗口宽度发生变化的时候也要再次适配
    remSize()
}
```



##### index.html中引入适配

public文件夹下的index.html中引入用于适配的js文件，参考上面icon图标的引入方式，采用baseurl的形式

```
<!-- 引入移动端适配的js文件 -->
//参考前面引入字体图标的方式，采用baseurl的形式
<script src="<%= BASE_URL %>js/rem.js"></script>
```





#### 引入字体图标

1）[阿里巴巴图标库](https://www.iconfont.cn/?spm=a313x.7781069.1998910419.d4d0a486a)，新建项目加入需要用到的字体图标

2）项目图标的代码引入index.html（注意图标使用的是Symbol形式）

```
  <!-- 引入字体图标 -->
  <script src="//at.alicdn.com/t/c/font_3965057_1lg36khx9fs.js"></script>
```

3）页面使用图标

参考[使用帮助](https://www.iconfont.cn/help/detail?spm=a313x.7781069.1998910419.d8cf4382a&helptype=code)

```
<svg class="icon" aria-hidden="true">
     <use xlink:href="#icon-31liebiao"></use>
</svg>
```

4）设置总体图标的样式（App.vue中设置全局的）

```
.icon{
  width: .4rem;
  height: .4rem;
}
```

5）安装插件px->rem可以自动将px单位转换为适应性的rem单位，同时还要调整字体大小

<img src="%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E9%A1%B9%E7%9B%AE%EF%BC%88%E7%A7%BB%E5%8A%A8%E7%AB%AF%EF%BC%89.assets/image-20230320205735241.png" alt="image-20230320205735241" style="zoom:67%;" />





#### 搭建头部导航

![image-20230330211103439](%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E9%A1%B9%E7%9B%AE%EF%BC%88%E7%A7%BB%E5%8A%A8%E7%AB%AF%EF%BC%89.assets/image-20230330211103439.png)

1）components文件夹下新建home/TopNav.vue

```
<!-- 头部导航组件:分为3个部分区域 -->
<template>
  <div class="topNav">
    <svg class="topleft icon" aria-hidden="true">
        <use xlink:href="#icon-31liebiao"></use>
    </svg>
    <div class="topContent">
        <span>我的</span>
        <span class="active">发现</span>
        <span>云村</span>
        <span>视频</span>
    </div>
    <svg class="topright icon" aria-hidden="true">
        <use xlink:href="#icon-sousuo"></use>
    </svg>
  </div>
</template>


<style lang="less" scoped>    
    .topNav{
        width: 100%;
        height: 1rem;
        padding: .2rem;
        display: flex;
        justify-content: space-between;
        align-items: center;
        .topleft{
            height: 100%;
        }
        .topright{
            height: 100%;
        }
        .topContent{
            width: 65%;
            height: 100%;
            display: flex;
            justify-content: space-around;
            align-items: center;
            font-size: .32rem;
            .active{
                font-weight: 700;
            }
        }
    }
</style>
```

注意点：如果topleft和topright外面再套一层div就会导致图标和字体盒子之间高度不一致，对不平

2）HomeView.vue中导入渲染TopNav

```
<template>
  <div class="home">
    <TopNav/>
  </div>
</template>

<script>
//引入头部导航组件
import TopNav from '@/components/home/TopNav.vue'; 
export default {
  name: 'HomeView',
  components: {
      TopNav
  }
}
</script>
```





#### Vant组件库

[官网](https://youzan.github.io/vant-weapp/#/home#jie-shao)

##### 通过npm安装

```
//Vue3项目中安装最新版本
npm i vant

//Vue2项目中安装Vant2（指定版本）
npm i vant@latest-v2
```



##### 常规用法

```
import { createApp } from 'vue';
// 1. 引入你需要的组件
import { Button } from 'vant';
// 2. 引入组件样式
import 'vant/lib/index.css';
const app = createApp();
// 3. 注册你需要的组件
app.use(Button);
```



##### 按需引入组件样式

(基于vue-cli创建的项目)

* 安装插件

```
# 通过 npm 安装
npm i unplugin-vue-components -D
```

* 配置插件

```
//在vue.config.js中配置插件
const { VantResolver } = require('unplugin-vue-components/resolvers');
const ComponentsPlugin = require('unplugin-vue-components/webpack');

module.exports = {
  configureWebpack: {
    plugins: [
      ComponentsPlugin({
        resolvers: [VantResolver()],
      }),
    ],
  },
};
```

* 使用插件

```
<template>
   <van-button type="primary">主要按钮</van-button>
</template>
```





#### 首页轮播图的配置

![image-20230330211135634](%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E9%A1%B9%E7%9B%AE%EF%BC%88%E7%A7%BB%E5%8A%A8%E7%AB%AF%EF%BC%89.assets/image-20230330211135634.png)

使用上面常规方法引入组件存在一个问题，每次新引入一个组件都需要重新调用一次app.use( )方法。解决：封装一个插件对所有引入的组件进行集中管理，在遍历插件数组的同时循环调用方法

##### 集中管理Vant组件

###### 封装插件

src文件夹下新建plugins/index.js

```
import { def } from "@vue/shared";
import { Button, Swipe, SwipeItem } from "vant";
//将引入将来的组件存入数组中
let plugins = [
    Swipe, SwipeItem, Button
]
//定义并且暴露方法，循环调用app.use()
export default function getVants(app) {
    plugins.forEach((item) => {
        return app.use(item)
    })
}
```

###### 使用自定义插件

main.js文件中引入并且使用（注意要传入app这个参数）

```
//引入自定义的插件
import getVants from './plugins'
...
//使用插件循环调用app.use()方法
getVants(app)
```



##### Swiper.vue

###### 基础显示

1）components/home文件夹下新建Swiper.vue。使用Vant的Swiper组件搭建基本结构

因为后面都是获取接口里面的数据来渲染，所以这里最好使用懒加载的形式

```
<template>
	<van-swipe :autoplay="3000" lazy-render>
  		<van-swipe-item v-for="image in images" :key="image">
    		<img :src="image" />
  		</van-swipe-item>
	</van-swipe>
<template>

<script>
	export default {
  		setup() {
    		const images = [
      			'https://fastly.jsdelivr.net/npm/@vant/assets/apple-1.jpeg',
      			'https://fastly.jsdelivr.net/npm/@vant/assets/apple-2.jpeg',
    		];
    		return { images };
  		},
	};
</script>

//自定义的基础样式
<style lang="less" scoped> 
.van-swipe{
    width: 100%;
    padding: 10px;
    .van-swipe__track{
      .van-swipe-item{
        img{
            width: 100%;
            height: 150px;
        }
      }
    }
}
</style>
```

2）HomeView.vue组件中引入并且使用轮播

```
<template>
  <div class="home">
    ...
    <SwiperTop/>
  </div>
</template>

<script>
import SwiperTop from '@/components/home/SwiperTop.vue';
export default {
  name: 'HomeView',
  components: {
    ...
    SwiperTop,
  }
}
</script>
```

###### 动态显示（接口数据）

1）安装axios用于获取数据

```
npm i axios
```

2）引入生命周期钩子

```
import { onMounted } from 'vue';
```

3）修改images为响应式数据

```
import { reactive,onMounted } from 'vue';
setup(){
	//定义为响应式数据，方便获取和添加数据
    const state = reactive({
      images: []
    })
    ...
}
```

4）获取动态数据

```
 setup() {
    //定义为响应式数据，方便获取和添加数据
    const state = reactive({
      images: []
    })
    onMounted(() => {
        axios.get('http://localhost:3000/banner?type=2').then((res) => {
          console.log(res);
          state.images = res.data.banners;
          console.log(state.images);
        })
    })
    //返回响应式对象
    return { state};
  },
```

5）轮播组件中渲染照片

```
  <!-- 轮播图 -->
    <van-swipe :autoplay="3000" lazy-render>
        <!-- 遍历的只是每一项banners，要显示图片还需要获取到banner里面的图标地址pic -->
        <van-swipe-item v-for="image in state.images" :key="image">
          <img :src="image.pic" />
        </van-swipe-item>
    </van-swipe>
```



##### 封装axios

[axios文档](http://www.axios-js.com/zh-cn/docs/)

###### 创建axios实例

src下新建request/index.js文件，该文件存放axios创建的实例

```
//后面请求数据的时候可以使用配置项和当前实例的配置项进行合并：就不用每次都写基础路径，也方便上线时修改
import axios from "axios";
let service = axios.create({
    baseURL: 'http://localhost:3000', //基础路径
    timeout: 3000  //请求响应时间
})

export default service
```

###### 封装获取数据的api

request文件夹下新建api/home.js用来获取首页数据

```
//引入axios的service实例
import service from "..";

//获取首页轮播图的数据
export function getBanner() {
    return service({
        methods: "GET",
        url: '/banner?type=2'
    })
}
```

###### 使用封装api获取数据

在SwiperTop.vue中修改代码，使用封装的api代替前面的axios请求（注意要使用异步请求的方式，axios采用的是then实现了异步请求）

```
//引入获取轮播图数据
import { getBanner} from '@/request/api/home'
....
onMounted(async() => {
      //异步请求
      let res = await getBanner();
      state.images = res.data.banners;
      console.log(res);
    })
```





#### 图标组件的编写

![image-20230330211154663](%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E9%A1%B9%E7%9B%AE%EF%BC%88%E7%A7%BB%E5%8A%A8%E7%AB%AF%EF%BC%89.assets/image-20230330211154663.png)

1）阿里巴巴图标库中找到合适的图标，更新代码，引入到public/index.html中

2）src/components/home文件夹下新建IconList.vue组件

```
<template>
  <div class="iconList">
    <div class="iconItem">
        <svg class="icon" aria-hidden="true">
            <use xlink:href="#icon-tuijian"></use>
        </svg>
        <span>
            每日推荐
        </span>
    </div>
    <div class="iconItem">
        <svg class=" icon" aria-hidden="true">
            <use xlink:href="#icon-weibiaoti-"></use>
        </svg>
        <span>
            私人FM
        </span>
    </div> 
    <div class="iconItem">
        <svg class=" icon" aria-hidden="true">
            <use xlink:href="#icon-gedan"></use>
        </svg>
        <span>
            歌单
        </span>
    </div> 
    <div class="iconItem">
        <svg class=" icon" aria-hidden="true">
            <use xlink:href="#icon-paihangbang"></use>
        </svg>
        <span>
            排行榜
        </span>
    </div>
  </div>
</template>
```

3）图标列表组件引入到HomeView.vue页面

```
<template>
  <div class="home">
	...
    <IconList/>
  </div>
</template>

<script>
...
import IconList from '@/components/home/IconList.vue'

export default {
  name: 'HomeView',
  components: {
  	...
    IconList
  }
}
</script>
```

4）修改图标列表的样式

```
<style lang="less" >
    .iconList{
        width: 100%;
        height: 2rem;
        margin-top: .10rem;
        display: flex;
        justify-content: space-around;
        align-items: center;
        .iconItem{
            width: 25%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            .icon{
                width: .6rem;
                height: .6rem;
            }
            span{
                font-size: .28rem;
            }
        }
    }
</style>
```





#### 推荐歌单

<img src="%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E9%A1%B9%E7%9B%AE%EF%BC%88%E7%A7%BB%E5%8A%A8%E7%AB%AF%EF%BC%89.assets/image-20230330211219827.png" alt="image-20230330211219827" style="zoom:67%;" />

##### 推荐歌单的头部

1）src/components/home文件夹下新建MusicList.vue文件作为推荐歌单的组件

```
<template>
  <div class="musicList">
    <div class="musicTop">
        <div class="title">
            推荐歌单 
            <svg class=" icon" aria-hidden="true">
                <use xlink:href="#icon-gengduo"></use>
            </svg>
        </div>
        <div class="more">查看更多</div>
    </div>
   </div>
</template>
...
```

2）在HomeView.vue组件中引入并且渲染

```
<template>
  <div class="home">
   	....
    <MusicList/>
  </div>
</template>

<script>
import MusicList from '@/components/home/MusicList.vue'
export default {
  name: 'HomeView',
  components: {
    ...
    MusicList
  }
}
</script>
```

3）修改MusicList的样式

```
<style lang="less">
    .musicList{
        width: 100%;
        height: 4rem;
        padding: 0.2rem;
        .musicTop{
            width: 100%;
            height: 0.6rem;
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.2rem;
            .title{
                font-size: 0.4rem;
                font-weight: 900;
                display: flex;
                flex-direction: row;
                align-items: center;
                .icon{
                        font-size: .27rem;
                        align-items: center;
                        margin-left: 0;
                    }
            }
            .more{
                border: 1px solid #ccc;
                font-size: 0.2rem;
                text-align: center;
                line-height: 0.6rem;
                padding: 0 0.2rem;
                border-radius: 0.4rem;
            }
        }
 	}
```



##### 获取后台歌单数据

1）request/api/home.js中添加获取推荐歌单数据的api

```
//获取每日推荐歌单的数据
export function getMusicList() {
    return service({
        method: 'GET',
        //limit=10参数表示限制获取10条数据
        url: '/personalized?limit=10'
    })
}
```

2）MusicList.vue组件中引入调用获取歌单的接口得到数据

```
//引入
import { getMusicList } from '@/request/api/home'
import { onMounted, reactive } from 'vue'
```

* Vue2的写法

```
//调用
export default{
	data() {
        return {
            musicList: [],
        }
    },
    methods: {
        //获取推荐个歌单的数据
        async getGeDan() {
            let res = await getMusicList();
            console.log(res);
            this.musicList=res.data.result
        },
    },
    mounted() {
        this.getGeDan()
    }
}
```

* Vue3的写法

```
export default{
	  setup() {
	  	//数据要定义为响应式的
        const state = reactive({
            musicList: []
        });
        //异步获取
        onMounted(async () => {
            let res = await getMusicList();
            console.log(res);
            state.musicList = res.data.result;
        });
        //注意要返回外面才能够调用
        return { state };
    }
}
```

3）渲染推荐歌单

使用的是Vant组件库中的自定义滑块大小的轮播，:width指定了每一个滑块的宽度

```
  <div class="musicContent">
        <van-swipe :loop="false" :width="160" :show-indicators="false" class="my-swipe">
            <van-swipe-item  v-for="item in state.musicList" :key="item">
                        <img :src="item.picUrl" alt="">
                        <span class="playCount">
                            <svg class=" icon" aria-hidden="true">
                                <use xlink:href="#icon-bofang1"></use>
                            </svg>
                            {{item.playCount}}
                        </span>
                        <span class="name">{{ item.name }}</span>
            </van-swipe-item>
        </van-swipe>
    </div>
    
    
    样式：
       .musicContent{
             width: 100%;
             .van-swipe-item{
                padding-right: .1rem;
                width: 100%;
                height: 5rem;
                box-sizing: border-box;
                position: relative;
                img{
                    width: 100%;
                    height: 3rem;
                    border-radius: .2rem;
                }
                .playCount{
                    position: absolute;
                    right: .3rem;
                    top: 0rem;
                    font-size: .27rem;
                    display: flex;
                    flex-direction: row;
                    align-items: center;
                    color: #ebebeb;
                    .icon{
                        font-size: .27rem;
                        align-items: center;
                        fill:#ebebeb;
                    }
                }
                .name{
                    display: block;
                    width: 100%;
                    height: 2rem;
                    line-height: .4rem;
                    font-size: .3rem;
                    text-align: left;
                }
            }
        }
```

4）定义函数处理播放量显示格式

注意：如果使用Vue3的方式同样也需要return之后才可以使用该函数

```
//在setup里面定义处理显示格式的方法
function changeCount(num) {
            if (num >= 100000000) {
                return (num / 10000000).toFixed(1) + '亿';
            } else if (num >= 10000) {
                return (num / 1000).toFixed(1) + '万';
            }
     };
     
 ....
 //需要将方法和数据返回给组件使用
return { state, changeCount };
```

```
轮播组件中的播放量由{{item.playCount}}修改为：
{{changeCount(item.playCount)}}
```





#### 推荐歌单详情页面



##### 点击路由跳转

点击某一个歌单之后就会跳转到该歌单对应的详情页面

1）在views文件夹下新建一个路由页面ItemMusic.vue

2）在路由的管理配置文件中定义router/index.js（每次新增一个路由页面都需要在路由管理配置文件中定义）

```
//歌单详情页面路由
  {
    path: '/ItemMusic',
    name: 'ItemMusic',
    component: () => import(/* webpackChunkName: "ItemMusic" */ '../views/ItemMusic.vue')
  }
```

3）MusicList.vue组件中给每个滑块item项里面的内容包裹router-link实现跳转

注意：跳转的时候需要携带参数id，后台会根据歌单id跳转到不同的歌单详情界面

```
<!-- 路由跳转 -->
<router-link :to="{path:'/ItemMusic',query:{id:item.id}}" >
     <img :src="item.picUrl" alt="">
     ....
</router-link>
```

4）修改a标签的样式

router-link本质上是一个a标签，点击之后标签里面的文字就会变色，可以在App.vue中进行全局控制

```
a{
  color:black;
}
```



##### 歌单详情页中获取数据

1）ItemMusic歌单详情页中获取歌单的id，后面会根据这个id跳转到对应的歌单页面

```
<!-- 推荐歌单详情页面 -->
<template>
    <div>歌单详情页</div>
</template>

<script>
import { useRoute } from 'vue-router';
import { onMounted, reactive } from 'vue';

export default {
    name: 'ItemMusic',
    setup() {
        onMounted(() => {
            let id = useRoute().query.id
            console.log(id);
        });
    },
}
</script>
```

2）定义获取歌单详情数据的接口

request/api文件夹下新建item.js专门用于获取歌单详情页需要的数据

```
//获取歌单详情页的数据
import service from "..";
export function getMusicItemList(data) {
    return service({
        method: 'GET',
        //需要根据id来获取具体某个歌单的数据
        url: `/playlist/detail?id=${data}`
    })
}
```

3）ItemMusic.vue歌单详情页中调用接口获取数据

```
import { getMusicItemList } from '@/request/api/item'
....
export default {
    name: 'ItemMusic',
    setup() {
        const state = reactive({
            playlist:{}
        })
        onMounted(async () => {
            let id = useRoute().query.id
            console.log(id);
            let res = await getMusicItemList(id)
            console.log(res);
            state.playlist = res.data.playlist
        });
        return {state}
    },
}
```



##### 渲染歌单详情页面

###### 头部区域

<img src="%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E9%A1%B9%E7%9B%AE%EF%BC%88%E7%A7%BB%E5%8A%A8%E7%AB%AF%EF%BC%89.assets/image-20230329143347645-1680071634057-9.png" alt="image-20230329143347645" style="zoom: 80%;" />

1）components文件夹下新建item/ItemMusicTop.vue组件（歌单详情页面的头部区域）

2）ItemMusic.vue中引入头部组件，同时需要给子组件ItemMusicTop传递父级组件中的参数

```
<template>
	//将playlist数据传递给子组件ItemMusicTop
     <ItemMusicTop :playlist="state.playlist"/>
</template>
...
import ItemMusicTop from '@/components/item/ItemMusicTop.vue';
...
 components: {
        ItemMusicTop,
    }
```

3）ItemMusicTop中接收父级传递过来的数据

```
export default{
	setup(props){
		consloe.log(props)
	},
	//接收父级传递过来的数据
	props:['playlist']
}
```

4）歌单详情页面头部区域的顶部内容搭建：itemMusicTop

![image-20230329143438796](%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E9%A1%B9%E7%9B%AE%EF%BC%88%E7%A7%BB%E5%8A%A8%E7%AB%AF%EF%BC%89.assets/image-20230329143438796.png)

主要是：①icon图标的使用    ②flex布局   ③背景图片的虚化

```
//布局
<div class="itemMusicTop">
		//背景图片
        <img :src="playlist.coverImgUrl" alt="" class="bgimg">
        
        <div class="itemLeft">
        	//给左箭头绑定点击事件：返回上一级菜单
            <svg class=" icon" aria-hidden="true" @click="$router.go(-1)">
              <use xlink:href="#icon-arrowLeft-fill"></use>
            </svg>
            <span>歌单</span>
        </div>
        
        <div class="itemRight">
            <svg class=" icon" aria-hidden="true">
              <use xlink:href="#icon-sousuo"></use>
            </svg>
            <svg class=" icon" aria-hidden="true">
              <use xlink:href="#icon-31liebiao"></use>
            </svg>
        </div>
</div>
```

```
//样式(注意保证一行icon图标的居中显示)
    .itemMusicTop{
        width: 100%;
        height: 1rem;
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: .2rem;
        position: relative;
        .itemLeft,.itemRight{
            width: 25%;
            height: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 0 .2rem;
            span{
                font-size: .37rem;
                color: #fff;
            }
            .icon{
                fill: #fff;
            }
        }

		//背景图片的虚化处理
        .bgimg{
            width: 100%;
            height: 11rem;
            position: fixed;
            z-index: -1;
            //背景虚化
            filter:blur(30px)
        } 
    }
```

5）歌单详情页面头部区域的中间内容搭建：itemTopContent

<img src="%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E9%A1%B9%E7%9B%AE%EF%BC%88%E7%A7%BB%E5%8A%A8%E7%AB%AF%EF%BC%89.assets/image-20230329144218162-1680072177889-11.png" alt="image-20230329144218162" style="zoom:80%;" />

```
//布局
<div class="itemTopContent">
		//左边封面
        <div class="contentLeft">
            <img :src="playlist.coverImgUrl" alt="">
            <span class="playCount">
                <svg class="icon" aria-hidden="true">
                    <use xlink:href="#icon-bofang1"></use>
                </svg>
                <span> {{changeCount(playlist.playCount)}}</span>
            </span>
        </div>
        
        //右边文字介绍
        <div class="contentRight">
           <p class="rightP_one">{{playlist.name}}</p>
           <div class="right_img">
                <img :src="playlist.creator.avatarUrl" alt="">
                <span>{{ playlist.creator.nickname }}</span>
                <svg class="icon" aria-hidden="true">
                    <use xlink:href="#icon-gengduo"></use>
                </svg>
           </div>
           <div class="rightP_two">
                <p>{{playlist.description}}</p>
                <svg class="icon" aria-hidden="true">
                    <use xlink:href="#icon-gengduo"></use>
                </svg>
           </div>
        </div>
  </div>
```

```
//样式
   .itemTopContent{
        width: 100%;
        height: 3rem;
        padding: 0.2rem;
        margin-top: 0.4rem;
        display: flex;
        justify-content: space-between;
        .contentLeft{
            width: 2.6rem;
            height: 2.6rem;
            position: relative;
            margin-right: .2rem;
            img{
                width: 2.6rem;
                height: 2.6rem;
                border-radius: .2rem;
            }
            .playCount{
                position: absolute;
                padding: .1rem;
                right: 0;
                top:0;
                z-index: 99;
                color: #fff;
                font-size: .2rem;
                .icon{
                    width: .4rem;
                    height: .4rem;
                    margin-right: .04rem;
                    vertical-align: middle;
                    fill: #fff;
                }
                span{
                    vertical-align: middle;
                    color: #fff;
                }
            }
        }
        .contentRight{
            width: 60%;
            height: 2.6rem;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            .rightP_one{
                font-size: 0.3rem;
                font-weight: 700;
                color: #fff;
            }
            .right_img,.rightP_two{
                width: 100%;
                color: #e6e6e6;
                .icon{
                    fill: #fff;
                }
            }
            .right_img{
                height: .6rem;
                display: flex;
                align-items: center;
                img{
                    width: .6rem;
                    height: .6rem;
                    border-radius: 50%;
                    vertical-align: middle;
                }
                span{
                    padding: .1rem;
                    font-size: .3rem;
        
                }
                .icon{
                    width: .26rem;
                    height: .26rem;
                    vertical-align: middle;
                    left: 0;
                }
            }
            .rightP_two{
                height: .6rem;
                display: flex;
                align-items: center;
                justify-content: space-between;
                p{
                    display: block;
                    width: 95%;
                    height: 100%;
                    font-size: 0.24rem;
                    overflow: hidden;
                    color: #d6d6d6;
                }
                .icon {
                    width: 0.24rem;
                    height: 0.24rem;
                }
            }
        }
    }
```

```
//在setup里面定义函数对播放量处理
        function changeCount(num) {
            if (num >= 100000000) {
                return (num / 10000000).toFixed(1) + '亿';
            } else if (num >= 10000) {
                return (num / 1000).toFixed(1) + '万';
            }
        };
        //注意需要return，外面才能使用
        return { changeCount };
```

6）歌单详情页面头部区域的底部导航内容搭建：itemTopNav

<img src="%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E9%A1%B9%E7%9B%AE%EF%BC%88%E7%A7%BB%E5%8A%A8%E7%AB%AF%EF%BC%89.assets/image-20230329144318371.png" alt="image-20230329144318371" style="zoom:80%;" />

主要是：①icon图标的使用   ②flex布局

```
//布局
<div class="itemTopNav">
        <div class="navItem">
            <svg class="icon" aria-hidden="true">
                <use xlink:href="#icon-message"></use>
            </svg>
            //动态显示歌单的评论量
            <span>{{playlist.commentCount}}</span>
        </div>
        <div class="navItem">
            <svg class="icon" aria-hidden="true">
                <use xlink:href="#icon-fenxiang1"></use>
            </svg>
            //动态显示歌单的分享量
            <span>{{playlist.shareCount}}</span>
        </div>
        <div class="navItem">
            <svg class="icon" aria-hidden="true">
                <use xlink:href="#icon-download"></use>
            </svg>
            <span>下载</span>
        </div>
        <div class="navItem">
            <svg class="icon" aria-hidden="true">
                <use xlink:href="#icon-show_duoxuan"></use>
            </svg>
            <span>多选</span>
        </div>
  </div>
```

```
//样式
 .itemTopNav{
        width: 100%;
        height: 1.4rem;
        display: flex;
        justify-content: space-around;
        margin-top: .2rem;
        .navItem{
            display: flex;
            flex-direction: column;
            align-items: center;
            color: #fff;
            .icon{
                width: 28%;
                height: 45%;
                fill: #e9e9e9;
            }
            span{
                display: block;
                font-size: .3rem;
                height: .4rem;
                margin-top: .1rem;
            }
        }
    }
```

7）歌单详情页面刷新之后报错：获取不到playlist数据

* ItemMusic.vue父组件中先把playlist数据保存在sessionStorage

```
onMounted(async()=>{
	....
	//防止页面刷新，数据丢失，将数据保存到sessionStorage里面
   sessionStorage.setItem('itemDetail',JSON.stringify(state))
})
```

* ItemMusicTop.vue子组件中先判断，看是否需要在sessionStorage中拿数据

```
setup(props){
	 //playlist数据里面作者信息层级较深，需要展开判断是否已经获取到
	 //通过props进行传递，判断如果拿不到数据，就去获取sessionStorage里面的数据
    if ((props.playlist.creator = "")) {        					  
    	props.playlist.creator=JSON.parse(sessionStorage.getItem().playlist).creator
  	}
 	....
}
```





###### 歌曲列表

1）components/item文件夹下新建ItemMusicList.vue组件（歌单详情下的所有歌曲列表区域）

2）ItemMusic.vue中引入歌曲列表组件

```
<template>
    <ItemMusicTop :playlist="state.playlist"/>
    <ItemMusicList/>
</template>
...
import ItemMusicList from '@/components/item/ItemMusicList.vue';
...
components: {
	...
    ItemMusicList
 }
```

3）request/api/item.js中定义获取歌曲列表的api

```
//获取歌单的所有歌曲列表
export function getItemList(data) {
    return service({
        method: "GET",
        // 传入limit=10&offset=0等价于limit=10，你会得到第1-10首歌曲
        url: `/playlist/track/all?id=${data}&limit=20&offset=0`
    })
}
```

4）ItemMusic页面中调用接口获取歌曲列表并且将歌曲列表数据传递到ItemMusicList页面

```
//传递数据
<!-- 推荐歌单详情页面 -->
<template>
    <ItemMusicTop :playlist="state.playlist"/>
    <!-- 传入歌曲列表数据以及歌单列表的收藏量数据 -->
    <ItemMusicList :itemlist="state.itemlist"
    :subscribedCount="state.playlist.subscribedCount"/>
</template>

//引入
import { getMusicItemList ,getItemList} from '@/request/api/item'

//调用
 setup() {
        const state = reactive({
            playlist: {},  //歌单详情页的数据
            itemlist:[]  //歌单的歌曲列表数据
        })
        onMounted(async () => {
            let id = useRoute().query.id
            console.log(id);
            //获取歌单详情页
           	....
            //获取歌单歌曲列表
            let result = await getItemList(id)
            console.log(result);
            state. itemlist= result.data.songs
			....
        });
        return {state}
    },
```

5）ItemMusicList页面中接收传递过来的数据

```
<script>
export default {
    name: "ItemMusicList",
    // 接收数据
    setup(props) {
        console.log(props);
    },
    props:['itemlist','subscribedCount']
}
</script>
```

6）ItemMusicList歌曲列表的搭建---头部的itemListTop

主要是：①icon的使用   ②flex布局   ③边框圆角的实现

<img src="%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E9%A1%B9%E7%9B%AE%EF%BC%88%E7%A7%BB%E5%8A%A8%E7%AB%AF%EF%BC%89.assets/image-20230329152250395-1680074574404-13.png" alt="image-20230329152250395" style="zoom:80%;" />

```
//布局
 <div class="itemListTop">
        <div class="listLeft">
            <svg class="icon" aria-hidden="true">
                <use xlink:href="#icon-bofang"></use>
            </svg>
            <span>播放全部<span> (共{{itemlist.length}}首) </span></span>
        </div>
        
       <div class="listRight">
            <svg class="icon" aria-hidden="true">
                <use xlink:href="#icon-aixin"></use>
            </svg>
            <span>收藏({{subscribedCount}})</span>
       </div>
</div>
```

```
//样式
    .itemMusicList{
        width: 100%;
        height: 11rem;
        background-color: #fff;
        // 设置圆角效果，只有左上和有上才有
        border-radius: .4rem .4rem 0 0;

        .itemListTop{
            width: 100%;
            height: 1.2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 .2rem;
            padding-top: .2rem;

            .listLeft{
                width: 3rem;
                height: 100%;
                display: flex;
                justify-content: space-between;
                align-items: center;
                .icon{
                    width: .5rem;
                    height: .5rem;
                    fill: #999;
                }
                span{
                    font-weight: 550;
                    font-size: .3rem;
                    color: #535353;
                    span{
                        font-weight: 400;
                        font-size: 0.24rem;
                        color: #999;
                    }
                }
            }

            .listRight{
                display: flex;
                align-items: center;
                padding: .2rem;
                border-radius: .4rem;
                color: #535353;
                .icon{
                    width: .5rem;
                    height: .5rem;
                    margin-right: .05rem;
                }
                span{
                    font-size: .3rem;
                    font-weight: 550;
                }
            }
        }
	}
```

7）ItemMusicList歌曲列表的搭建---歌曲列表itemListContent

主要是：①列表渲染    ②条件渲染

注意点：

①每一首歌曲前面的序号，在遍历歌曲的时候传入索引i，后面使用i+1作为歌曲的序号。（最好判断序号是一位数还是两位数）

```
//条件渲染
<span class="index" v-if="i<9">0{{i+1}}</span>
<span class="index" v-else>{{i+1}}</span>
```

②一首歌可能会存在多位歌手：遍历展示歌手姓名

```
 <span v-for="(ar,index) in item.ar" :key="index">
      <!-- 如果有多个歌手，需要遍历 -->
      {{ar.name}}&nbsp
 </span>
```

③歌曲信息中如果有mv就渲染mv相关的icon图标

```
<!-- 有mv就渲染mv的字体图标 -->
<svg class="icon" aria-hidden="true" v-if="item.mv!= 0">
     <use xlink:href="#icon-bofangMV"></use>
</svg>
```

```
   <div class="itemListContent">
   		//左边歌名以及歌手
        <div class="itemList" v-for="(item,i) in itemlist" :key="i"  >
            <div class="listLeft" @click="playMusic(i)">
                <span class="index" v-if="i<9">0{{i+1}}</span>
                <span class="index" v-else>{{i+1}}</span>

                <div class="content">
                    <p>{{ item.name }}</p>
                    <span v-for="(ar,index) in item.ar" :key="index">
                        <!-- 如果有多个歌手，需要遍历 -->
                        {{ar.name}}&nbsp
                    </span>
                </div>
            </div>
           
           //右边图标
            <div class="listRight">
                <!-- 有mv就渲染mv的字体图标 -->
                <svg class="icon" aria-hidden="true" v-if="item.mv!= 0">
                    <use xlink:href="#icon-bofangMV"></use>
                </svg>
                <svg class="icon liebiao" aria-hidden="true">
                    <use xlink:href="#icon-31liebiao"></use>
                </svg>
            </div>
        </div>
        
    </div>
```

```
//样式
   .itemListContent{
            width: 100%;
            background-color: #fff;
            .itemList{
                width: 100%;
                height: 1.4rem;
                padding: 0 0.2rem;
                display: flex;
                justify-content: space-between;
                align-items: center;

                .listLeft{
                    width: 80%;
                    height: 100%;
                    display: flex;
                    align-items: center;
                    .index{
                        display: inline-block;
                        width:0.2rem;
                        text-align: center;
                        font-size: .35rem;
                        color: #535353;
                    }
                    .content{
                        margin-left: 0.5rem;
                        p{
                            margin-bottom: -0.5rem;
                            width: 4.54rem;
                            height: .5rem;
                            overflow: hidden;
                            text-overflow: ellipsis;
                            white-space: nowrap;
                            font-weight: 700;
                            color: #535353;
                            font-size: .35rem;
                        }
                        span{
                            font-weight: 400;
                            font-size: .28rem;
                            color: #999;
                        }
                    }
                }

                .listRight{
                    width: 20%;
                    height: 100%;
                    display: flex;
                    align-items: center;
                    position: relative;
                    .icon{
                        position: absolute;
                        z-index: 2;
                        fill: #999;
                    }
                    .liebiao{
                        position: absolute;
                        right: 0;
                    }
                }
            }

            .itemList:hover{
                background-color: #ddd;
            }

        }
```





#### 底部组件

##### 组件新建&渲染

1）components/item文件夹下新建FooterMusic.vue文件作为底部组件

2）底部组件在多个地方都用到，当作一个全局组件，直接在App.vue中渲染

```
<template>
  <router-view/>
  //App.vue中渲染底部组件
  <FooterMusic v-show="$store.state.isFooterMusic"/>
</template>

<script>
import FooterMusic from './components/item/FooterMusic.vue';
export default {
  components: {
    FooterMusic,
  }
}
</script>

```



##### 全局配置播放列表

底部组件是一个全局组件，里面的播放列表以及状态都是需要全局共享的

在store/index.js里面配置全局共享的状态

```
export default createStore({
  state: {
    //播放列表指定默认值
    playList: [{
      //专辑信息
      al: {
        id: 161799333,
        name: "声生不息·宝岛季 第1期",
        pic: 109951168469139970,
        picUrl: "http://p3.music.126.net/7C9M22jEr3W7VDQxTsjW7Q==/109951168469139967.jpg"
      },
      //歌曲信息
      id: 2030766928,
      name: "想见你想见你想见你(live版)",
      ar: [{ name: '张杰' }]
    }],
    playListIndex: 0,  //切换下一首,下标
  },
  ...
}
```



##### 底部组件结构搭建

<img src="%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E9%A1%B9%E7%9B%AE%EF%BC%88%E7%A7%BB%E5%8A%A8%E7%AB%AF%EF%BC%89.assets/image-20230329160148144.png" alt="image-20230329160148144" style="zoom:80%;" />

主要：①如何获取store/index.js中配置的默认数据    ②icon图标&flex布局

```
//布局
<div class="FooterMusic">
	//左边图片&歌曲
    <div class="footerLeft" @click="updateDetailShow">
        <img :src="playList[playListIndex].al.picUrl" alt="">
        <div>
            <p>{{playList[playListIndex].name}}</p>
            <span>横滑可以切换上下首</span>
        </div>
    </div>
    
    //右边图标
    <div class="footerRight">
        <svg class="icon" aria-hidden="true">
            <use xlink:href="#icon-bofang"></use>
        </svg>
        <svg class="icon" aria-hidden="true">
            <use xlink:href="#icon-24gf-playlistMusic"></use>
        </svg>
    </div>
</div>
```

```
//获取store/index.js中的数据
export default {
	...
	 computed: {
	 //使用扩展运算符获取到播放列表以及歌曲的下标(下标用于歌曲的切换)
        ...mapState(['playList','playListIndex'])
    },
}
```

```
//样式
.FooterMusic{
        width: 100%;
        height: 1.4rem;
        background-color: #fff;
        position: fixed;
        bottom: 0;
        border-top: 1px solid #999;
        padding: .2rem;
        display: flex;
        justify-content: space-between;
        .footerLeft{
            width: 60%;
            height: 100%;
            display: flex;
            justify-content: space-around;
            align-items: center;
            img{
                width: 1rem;
                height: 1rem;
                border-radius: 50%;
            }
            p{
                width: 3rem;
                font-weight: 600;
                white-space: nowrap;  //不换行
                overflow: hidden;  //超出隐藏
                text-overflow: ellipsis;   //超出的文字省略号隐藏
                color: #535353;
                font-size: .35rem;
                margin-bottom:-.5rem
            }
            span{
                color: #999;
                font-size: .24rem;
            }
        }
        .footerRight{
            width: 20%;
            height: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            .icon{
                width: .45rem;
                height: .45rem;
            }
        }
    } 
```



##### 播放音乐

1）添加audio播放器并且绑定ref属性

```
<audio ref="audio"
	id="musicId"
	:src="`https://music.163.com/song/media/outer/url?id=${playList[playListIndex].id}.mp3`"
 ></audio>
```

给audio绑定ref，可以进行传值，父组件也可以通过ref找到对应属性的子组件标签

```
mounted(){
	console.log(this.$refs);
}
```

![image-20230329161404201](%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E9%A1%B9%E7%9B%AE%EF%BC%88%E7%A7%BB%E5%8A%A8%E7%AB%AF%EF%BC%89.assets/image-20230329161404201.png)

2）播放按钮绑定点击事件播放音乐

* store/index.js中定义控制播放状态的变量以及改变变量的mutations方法

当前歌曲的播放状态无论在首页还是歌曲详情页里面都需要保持一致：所以需要在sore/index.js里面定义一个布尔类型的变量来控制播放，同时需要定义一个mutations方法方便外部对于该变量的改变

```
isbtnShow: true, //暂停按钮显示，全局控制
...
mutations:{
	 //更改歌曲的播放暂停状态
    updateIsbtnShow: function (state, value) {
      state.isbtnShow = value
    },
}
```

* FooterMusic组件中根据播放状态显示播放/暂停按钮

```
<svg class="icon" aria-hidden="true" @click="play" v-if="isbtnShow">
   <use xlink:href="#icon-bofang"></use>
</svg>
<svg class="icon" aria-hidden="true" @click="play" v-else>
   <use xlink:href="#icon-tingzhi"></use>
</svg>
```

* 定义方法控制歌曲的播放暂停，同时注意要修改isbtnShow播放状态的值

```
methods:{
	   //解构获取到store/index.js里面mutations的方法，用于修改播放状态变量值
	   ...mapMutations(['updateIsbtnShow']),
	   play: function () {
            //判断当前音乐是播放还是暂停状态
            if (this.$refs.audio.paused) {
                this.$refs.audio.play();
                this.updateIsbtnShow(false);
            } else {
                this.$refs.audio.pause();
                this.updateIsbtnShow(true);
            } 
        },
}
```



##### 点击列表切换歌曲

1）store/index.js中定义更新播放列表的方法

```
mutations:{
	...
	//更新播放列表
    updatePlayList: function (state, value) {
      state.playList = value
    },
}
```

2）components/item/ItemMusicList.vue中定义方法点击歌曲添加整个歌单列表

```
 //点击歌单列表左边歌曲信息的时候就会触发播放事件(注意一定要传递索引下标整个参数)
 <div class="listLeft" @click="playMusic(i)">
  	....
  </div>
  
  methods: {
        ...mapMutations(['updatePlayList']),
        playMusic: function (i) {
            this.updatePlayList(this.itemlist)
        }
    }
```

3）store/index.js中定义更新播放歌曲下标的方法

```
//更新下标
updatePlayListIndex: function (state, value) {
      state.playListIndex = value
},
```

4）components/item/ItemMusicList.vue中调用playMusic方法时也要改变PlayListIndex

```
 methods: {
        ...mapMutations(['updatePlayList','updatePlayListIndex']),
        playMusic: function (i) {
            this.updatePlayList(this.itemlist)
            this.updatePlayListIndex(i)
        }
    }
```

5）FooterMusic中监听歌曲下标以及播放列表是否发生了改变，改变就设置自动播放

```
watch: {
        //监听歌曲的下标是否更改，更改了就自动播放
        playListIndex: function () {
            this.$refs.audio.autoplay = true;
            //如果当前是暂停状态,点击之后就会变为播放状态
            if (this.$refs.audio.paused) {
                this.updateIsbtnShow(false)
            }
         },
            
        //监听播放列表是否发生了改变
        playList: function () {
            if (this.isbtnShow) {
                this.$refs.audio.autoplay = true;
                this.updateIsbtnShow(false)
            }
        }
	}
```





#### 歌曲详情页

<img src="%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E9%A1%B9%E7%9B%AE%EF%BC%88%E7%A7%BB%E5%8A%A8%E7%AB%AF%EF%BC%89.assets/image-20230329175244386.png" alt="image-20230329175244386" style="zoom:67%;" />                <img src="%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E9%A1%B9%E7%9B%AE%EF%BC%88%E7%A7%BB%E5%8A%A8%E7%AB%AF%EF%BC%89.assets/image-20230329175545540.png" alt="image-20230329175545540" style="zoom:67%;" /><

##### 点击弹出

点击底部组件之后，就会在右边弹出层跳到歌曲详情页面中

1）Vant组件库中的右侧弹出层组件

```
//自定义的插件plugins/index.js中引入要使用的组件(后面每一个新使用的组件都要先在插件中引入)
//在下面2处地方添加新组件即可
import { Button, Swipe, SwipeItem, Popup, } from "vant";
//将引入将来的组件存入数组中
let plugins = [
    Swipe, SwipeItem, Button, Popup
]
```

2）Vuex中定义变量决定是否展示弹出层

```
//store/index.js中定义变量以及改变该变量的方法
detailShow: false, //全局控制歌曲详情页面的展示
...
mutations:{
	//修改歌曲详情页面的展示与否
    updateDetailShow: function (state) {
      state.detailShow = !state.detailShow
    },
}
```

3）FooterMusic中引入调用

```
//绑定点击事件
<div class="footerLeft" @click="updateDetailShow">
     <img :src="playList[playListIndex].al.picUrl" alt="">
     <div>
          <p>{{playList[playListIndex].name}}</p>
          <span>横滑可以切换上下首</span>
     </div>
</div>

//需要结构获取到vuex中的变量和方法
computed: {     
	...mapState(['playList','playListIndex','isbtnShow','detailShow'])
},
methods: {
    ...mapMutations(['updateIsbtnShow', 'updateDetailShow', 'updateCurrentTime', 'updateDuration']),
}
```

4）在FooterMusic.vue中放置弹出层

```
<van-popup v-model:show="detailShow" position="right" :style="{height:'100%', width:'100%'}">
 //后面再这里放歌曲详情页面
</van-popup>
```



##### 歌曲详情页面（静态）

1）components/item文件夹下新建MusicDetail.vue组件作为歌曲详情页面

2）FooterMusic中引入使用MusicDetail

```
<van-popup v-model:show="detailShow" position="right" :style="{height:'100%', width:'100%'}">
  	//使用的时候是放在弹出层
    <MusicDetail/>
</van-popup>
```

3）FooterMusic给MusicDetail传递数据（详情页的歌曲信息直接从父组件中获取）

```
<van-popup v-model:show="detailShow" position="right" :style="{height:'100%', width:'100%'}">
  	//使用的时候是放在弹出层
    <MusicDetail :musicList="playList[playListIndex]"/>
</van-popup>
```

4）MusicDetail接收父级传递过来的数据

```
export default{
	// 接收父组件传递过来的数据
    props: ['musicList'],
    mounted() {
      console.log(this.musicList); 
    },
}
```



###### 歌曲详情页头部

![image-20230329175722861](%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E9%A1%B9%E7%9B%AE%EF%BC%88%E7%A7%BB%E5%8A%A8%E7%AB%AF%EF%BC%89.assets/image-20230329175722861.png)

主要：①跑马灯效果  ②icon图标  ③flex布局

1）安装跑马灯组件

```
npm i vue3-marquee@latest
```

2）引入使用

```
<div class="detailTop">
    <div class="detailTopLeft">
        <svg class="icon" aria-hidden="true" @click="backHome">
            <use xlink:href="#icon-zuojiantou"></use>
        </svg>
       <div class="leftMarquee">
       		//跑马灯效果展示歌曲名称
            <Vue3Marquee>{{musicList.name}}</Vue3Marquee>
            //歌手
            <div class="ac">
                <span v-for="item in musicList.ar" ::key="item">
                    {{item.name}}&nbsp;
                </span>
                <svg class="icon" aria-hidden="true">
                    <use xlink:href="#icon-gengduo"></use>
                </svg>
            </div>
       </div>
    </div>
    
    
    <div class="detailTopRight">
        <svg class="icon" aria-hidden="true">
            <use xlink:href="#icon-fenxiang"></use>
        </svg>
    </div>
  </div>
...

export default{
	import { Vue3Marquee } from 'vue3-marquee'
	 components: {
        Vue3Marquee
    }
    ...
}
```

```
//样式
   .detailTop{
        width: 97%;
        height: 1rem;
        margin-top: .2rem ;
        margin-left: .1rem;
        margin-right: .1rem;
        display: flex;
        justify-content: space-between;
        align-items: center;
        fill:#fff;
        .icon{
            width: .6rem;
            height: .6rem;
        }
        .detailTopLeft{
            display: flex;
            align-items: center;
            color: #e8e8e8;
            .leftMarquee{
                width: 2rem;
                height: 100%;
                margin-left: .36rem;
                font-size: .4rem;

                .ac{
                    display: flex;
                    align-items: center;
                    .icon{
                        width: .3rem;
                        height: .3rem;
                }
                    span{
                        font-size: .3rem;
                        color: #bababa;
                    }
                }
            }
        }
    }
```

3）在detailTop上面添加一个图片作为虚化背景

```
 <img :src="musicList.al.picUrl" alt="" class="bgimg">
 .... 
//样式
 .bgimg{
        width: 100%;
        height: 100%;
        filter: blur(65px);
        position: absolute;
        z-index: -1;
    }
```

4）给顶部的左箭头添加点击事件，返回上一级（相当于是右侧的弹出层不显示）

```
 methods: {
 		//解构获取vuex中修改弹出层显示与否法方法
        ...mapMutations(['updateDetailShow']),
        //点击返回按钮之后恢复到磁盘效果页面
        backHome: function () {
            this.updateDetailShow() 
        },
 }
```



###### 歌曲详情页中间

<img src="%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E9%A1%B9%E7%9B%AE%EF%BC%88%E7%A7%BB%E5%8A%A8%E7%AB%AF%EF%BC%89.assets/image-20230329195154012.png" alt="image-20230329195154012" style="zoom:80%;" />

有3个部分构成：磁盘+磁针+中间专辑图片

静态基本结构搭建：

```
  <!-- 磁盘 -->
  <div class="detailContent" v-show="!isLyricShow">
    <img src="@/assets/needle.png" class="img_needle" alt="" >
    <img src="@/assets/disc.png" class="img_cd" alt="">
    <img :src="musicList.al.picUrl" class="img_ar">
  </div>
```

```
 .detailContent{
        width: 100%;
        height: 9rem;
        display: flex;
        flex-direction: column;
        align-items: center;
        position: relative;
        .img_needle{
            width: 2rem;
            height: 3rem;
            position: absolute;
            left: 46%;
            transform-origin: 0 0;
            transform: rotate(-13deg);
            transition: all 2s;
        }
        .img_cd{
            width: 5rem;
            height: 5rem;
            position: absolute;
            bottom: 2.3rem;
            z-index: -1;
        }
        .img_ar{
            width: 3.2rem;
            height: 3.2rem;
            border-radius: 50%;
            position: absolute;
            bottom: 3.14rem;
            animation: rotate_ar 10s linear infinite;
        }
    }
```



###### 歌曲详情页底部

<img src="%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E9%A1%B9%E7%9B%AE%EF%BC%88%E7%A7%BB%E5%8A%A8%E7%AB%AF%EF%BC%89.assets/image-20230329200539056.png" alt="image-20230329200539056" style="zoom:80%;" />

静态基本结构搭建

```
 //布局
 <div class="detailFooter">
    <div class="footerTop">
        <svg class="icon" aria-hidden="true">
            <use xlink:href="#icon-aixin1"></use>
        </svg>
        <svg class="icon" aria-hidden="true">
            <use xlink:href="#icon-xiazai"></use>
        </svg>
        <svg class="icon" aria-hidden="true">
            <use xlink:href="#icon-yinle1"></use>
        </svg>
        <svg class="icon" aria-hidden="true">
            <use xlink:href="#icon-message"></use>
        </svg>
        <svg class="icon" aria-hidden="true">
            <use xlink:href="#icon-diandiandianshu"></use>
        </svg>
    </div>
	
	//中间进度条区域
	
    <div class="footer">
        <svg class="icon" aria-hidden="true">
            <use xlink:href="#icon-liebiaoxunhuan"></use>
        </svg>
        <svg class="icon" aria-hidden="true">
            <use xlink:href="#icon-shangyishou"></use>
        </svg>
        <svg class="icon play" aria-hidden="true">
            <use xlink:href="#icon-bofang"></use>
        </svg>
        <svg class="icon play" aria-hidden="true">
            <use xlink:href="#icon-tingzhi"></use>
        </svg>
        <svg class="icon" aria-hidden="true">
            <use xlink:href="#icon-xiayishou"></use>
        </svg>
        <svg class="icon" aria-hidden="true">
            <use xlink:href="#icon-24gf-playlist"></use>
        </svg>
    </div>
  </div>
```

```
 //样式
    .detailFooter{
        width: 100%;
        height: 3rem;
        position: absolute;
        bottom: .2rem;
        display: flex;
        flex-direction:column;
        justify-content: space-between;
        .icon{
                width: .6rem;
                height: .6rem;
                fill: #fff;
            }
        .footerTop,.footer{
            width: 100%;
            height: 1rem;
            display: flex;
            justify-content: space-around;
            align-items: center;
            .play{
                width: .9rem;
                height: .9rem;
            }
        }

    }
```



##### 实现播放音乐

1）在FooterMusic中将play方法以及isbtnShow变量传递给MusicDetail子组件

MusicDetail中无法获取到audio来控制播放，audio存在于父组件FooterMusic中，将父组件中控制音乐播放与暂停的方法传递给子组件；同时还需要传递表示播放暂停状态的isbtnShow变量，保证状态全局的一致性

```
 <MusicDetail :musicList="playList[playListIndex]" :play="play" :isbtnShow="isbtnShow" />
```

2）MusicDetail子组件中接收

```
props: ['musicList','isbtnShow','play'],
```

3）icon按钮绑定事件播放与暂停

```
//根据状态变量isbtnShow条件渲染播放暂停按钮的显示
//按钮都绑定FooterMusic中的播放方法paly
<svg class="icon play" aria-hidden="true"  v-if="isbtnShow" @click="play">
    <use xlink:href="#icon-bofang"></use>
</svg>
<svg class="icon play" aria-hidden="true"  v-else @click="play">
    <use xlink:href="#icon-tingzhi"></use>
</svg>
```



##### 磁盘动画效果

###### 磁针的起落

1）添加磁针落下的样式（主要是修改旋转的角度）

```
.img_needle_active{
            width: 2rem;
            height: 3rem;
            position: absolute;
            left: 46%;
            transform-origin: 0 0;
            transform: rotate(0deg);
            transition: all 2s;
        }
```

2）根据播放状态变量控制使用类名

```
  <!-- 磁盘 -->
  <div class="detailContent" v-show="!isLyricShow">
  	//如果当前是播放状态就添加.img_needle_active样式，让磁针落下
    <img src="@/assets/needle.png" class="img_needle" alt="" :class="{img_needle_active:!isbtnShow}">
    ...
  </div>
```



###### 专辑图片的旋转

1）style中添加旋转的动画（css3样式）

```
   // 磁盘里面的照片旋转
        @keyframes rotate_ar {
            0%{
                transform: rotateZ(0deg);
            }
            100%{
                transform: rotateZ(360deg);

            }
        }
```

2）img_ar样式中添加上定义的动画

```
.img_ar{
            width: 3.2rem;
            height: 3.2rem;
            border-radius: 50%;
            position: absolute;
            bottom: 3.14rem;
            //添加动画
            animation: rotate_ar 10s linear infinite;
        }
```

3）添加控制动画播放与暂停的样式

```
 .img_ar_active{
            animation-play-state: running;
        }
  .img_ar_pause{
			animation-play-state: paused;
        }
```

4）根据播放状态变量控制使用类名

```
<!-- 磁盘 -->
<div class="detailContent" v-show="!isLyricShow">
  //如果当前是播放状态：使用img_ar_active类名让动画开始；如果当前是暂停状态：使用img_ar_pause类名让动画停止
  ...
  <img :src="musicList.al.picUrl" class="img_ar" :class="{img_ar_active:!isbtnShow,img_ar_pause:isbtnShow}">
</div>
```



##### 歌词

<img src="%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E9%A1%B9%E7%9B%AE%EF%BC%88%E7%A7%BB%E5%8A%A8%E7%AB%AF%EF%BC%89.assets/image-20230330194114808.png" alt="image-20230330194114808" style="zoom:67%;" />

###### 封装获取歌词的API

在request/api/item.js中新增获取歌词的API接口

```
//获取歌曲的歌词
export function getMusicLyric(data) {
    return service({
        method: "GET",
        url: `/lyric?id=${data}`
    })
}
```

###### 获取歌词

1）store/index.js中获取歌词

歌曲详情页里面的内容都保存在在vuex中，歌词也可以采用异步方式在store/index.js中获取

```
//引入获取歌词的API
import { getMusicLyric } from '@/request/api/item';
...
export default createStore({
	//异步操作，所以保存在actions里面
	actions: {
    	//异步获取歌曲歌词
    	getLyric: async function (context, value) {
      		let res = await getMusicLyric(value)
      		console.log(res);
    	},
	}
})
```

2）底部组件更新的时候就要调用获取歌词

```
  //在FooterMusic.vue中添加updateed触发获取歌词的函数
  updated() {
        this.$store.dispatch("getLyric", this.playList[this.playListIndex].id);
    },
```

3）vuex中用对象接收歌词，添加方法修改

```
state:{
	...
	lyricList: {}, //歌词部分
	...
},
mutations:{
	...
	//更新歌词
    updateLyricList: function (state, value) {
      state.lyricList = value
    },
},
 actions: {
    //异步获取歌曲歌词
    getLyric: async function (context, value) {
      let res = await getMusicLyric(value)
      console.log(res);
      //提交到mutations中进行修改
      context.commit("updateLyricList", res.data.lrc)
    },
}
```



###### 初步展示

1）MusicDetail中定义布尔值变量决定歌词的显示与隐藏

```
 data() {
        //控制歌词和磁盘的显示与隐藏
        return {
            isLyricShow: false,
        }
    },
```

2）磁盘部分根据控制歌词显示隐藏的布尔值条件渲染

```
 <!-- 磁盘 -->
  <div class="detailContent" v-show="!isLyricShow">
 	....
  </div>
```

3）MusicDetail页面中初步渲染歌词内容

```
import { mapMutations,mapState} from 'vuex';
...
//在computed中解构然后在本页面使用
computed: {
        ...mapState(['lyricList']),
}
```

```
  //磁盘部分下面放置歌词内容
  <!-- 歌词 -->
  <div class="musicLyric"  v-show="isLyricShow">
        {{lyricList.lrc}}
  </div>
```



###### 处理歌词

实际上获取到的歌词格式如下：（需要手动切割然后渲染展示）

<img src="%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E9%A1%B9%E7%9B%AE%EF%BC%88%E7%A7%BB%E5%8A%A8%E7%AB%AF%EF%BC%89.assets/image-20230330181554628.png" alt="image-20230330181554628" style="zoom:80%;" />

1）MusicDetail中定义计算属性处理歌词数据

```
    lyric: function () {
            let arr;
            //先判断一下歌词对象是否为空
            if (this.lyricList.lyric) {
                arr = this.lyricList.lyric.split(/[(\r\n)\r\n]+/).map((item, i) => {
                    //分割出来时间以及每一句歌词
                    let min = item.slice(1, 3);
                    let sec = item.slice(4, 6);
                    let mill = item.slice(7, 10);
                    let lrc = item.slice(11, item.length);

                    //针对毫秒进行处理
                    if (isNaN(Number(mill))) {
                        mill = item.slice(7, 9);
                        lrc = item.slice(10, item.length);
                    }
                    // console.log(min, sec, Number(mill), lrc);
                    //返回对象，方便后面对时间的操作
                    return {min,sec,mill,lrc,time}
                })
            }
            return arr;
        },
```

2）循环渲染计算属性返回来数组里面的每一句歌词

```
  <div class="musicLyric" v-show="isLyricShow">
    <p v-for="item in lyric" :key="item">
        {{item.lrc}}
    </p>
  </div>
```

3）给歌词添加样式

```
 .musicLyric{
        width: 100%;
        height: 8rem;
        display: flex;
        flex-direction: column;
        align-items: center;
        margin-top: .2rem;
        overflow: scroll;
        p{
            color:#bababa;
            margin-bottom: .4rem;
            font-size: .32rem;
        }
    }
```



###### 歌词随播放突出显示

1）获取当前播放位置的时间

在计算属性中处理歌词前面时间的时候，返回当前歌词前面的总毫秒数

```
    lyric: function () {
            let arr;
            //先判断一下歌词对象是否为空
            if (this.lyricList.lyric) {
                arr = this.lyricList.lyric.split(/[(\r\n)\r\n]+/).map((item, i) => {
                    //分割出来时间以及每一句歌词
                    let min = item.slice(1, 3);
                    let sec = item.slice(4, 6);
                    let mill = item.slice(7, 10);
                    let lrc = item.slice(11, item.length);
					//返回时间,毫秒的形式
                    let time=parseInt(min)*60*1000+parseInt(sec)*1000+parseInt(mill)

                    //针对毫秒进行处理
                    if (isNaN(Number(mill))) {
                        mill = item.slice(7, 9);
                        lrc = item.slice(10, item.length);
                        //返回时间,毫秒的形式
                    	time=parseInt(min)*60*1000+parseInt(sec)*1000+parseInt(mill)

                    }
                    // console.log(min, sec, Number(mill), lrc);
                    //返回对象，方便后面对时间的操作
                    return {min,sec,mill,lrc,time}
                })
            }
            return arr;
        },
```

2）vuex中定义表示当前时间的变量以及修改变量的mutation函数

```
state:{
	 currentTime: 0,//开始的当前时间为0
},
mutations:{
	 //更新当前时间
    updateCurrentTime: function (state, value) {
      // console.log(state.currentTime);
      state.currentTime = value;
    },
}
```

3）FooterMusic中触发更新当前时间段函数

歌曲一直在播放，当前时间就会一直在改变。需要使用一个定时器

在FooterMusic的methods里面定义函数调用vuex里面更新当前时间的方法来改变当前播放到的时间（在FooterMusic中触发该函数是为了获取到audio中的属性currentTime）

* 歌曲在播放的时候才需要调用该函数
* 暂停播放就要清除定时器
* 先定义一个timer变量接收定时器

```
data() {
	//使用一个变量接收定时器，方便后面歌曲暂停播放的时候可以清空定时器，不再触发更新播放歌曲的当前时间
    return {
          timer:0,//定时器
  	}
},

methods:{
	  //点击播放方法
        play: function () {
            //判断当前音乐是播放还是暂停状态
            if (this.$refs.audio.paused) {
                ....
                this.updateTime();//音乐在播放的时候就会触发定时器
            } else {
                .....
                clearInterval(this.timer); //暂停播放音乐时就会停止计时
            } 
        },
        
	//实时改变当前时间(使用定时器)
        updateTime: function () {
            this.timer=setInterval(() => {
                this.updateCurrentTime(this.$refs.audio.currentTime)
            },1000)
        }
}
```

4）在歌曲详情页面的时候也需要调用该函数更新当前时间：后面进入到详情页的时候才会定位到当前时间对应的歌词

FooterMusic页面中，初次渲染的时候就调用方法更新歌曲的当前时间

```
 mounted() {
        this.$store.dispatch("getLyric", this.playList[this.playListIndex].id);
        this.updateCurrentTime() //更新当前时间
    },
```

5）根据获取的当前时间比较突出显示那一句歌词

①在MusicDetail切割歌词的函数里面定义一个循环获取到下一句歌词的时间

```
//定义一个循环，获取下一句歌词开始的时间（用于做当前时间歌词的突出显示效果）
                arr.forEach((item,i) => {
                    //如果已经到达最后一句歌词
                    //最后一句歌词无法高亮显示，上一句获取到的pre是NaN
                    if (i === arr.length - 1||isNaN(arr[i+1].time)) {
                        item.pre=1000000
                    } else {
                        item.pre=arr[i+1].time
                    }
                });
```

②添加歌词高亮显示的样式

```
.active{
            font-size: .4rem;
            color:#fff;
        }
```

③MusicDetail页面中获取到歌曲播放到的当前时间

```
computed:{
	 ...mapState(['lyricList', 'currentTime',]),
	 ....
}
```

④当前时间>当前歌词的item时间 && 当前时间<下一句歌词的item时间，同时满足这两个条件，在渲染歌词时就添加高亮显示效果

```
 <!-- 添加ref获取监听歌词 -->
<div class="musicLyric"  v-show="isLyricShow">
	//当前时间>当前歌词的item时间&&当前时间<下一句歌词的item时间(满足条件就添加歌词高亮显示的样式效果)
	<p v-for="item in lyric" :key="item" :class="{active(currentTime*1000>=item.time&&currentTime*1000<item.pre)}">
        {{item.lrc}}
    </p>
  </div>
```

###### 歌词滚动问题

让当前高亮显示的歌词固定在某一位置，当歌曲播放的时候不会一直随着往下滚动

1）给当前歌词绑定ref（方便下面通过refs获取到当前歌词以及高度）

```
 <div class="musicLyric" ref="musicLyric" v-show="isLyricShow">
	....
  </div>
```

2）监视当前时间currenTime，让高亮的歌词距离顶部的位置固定

```
  watch: {
        currentTime: function (newValue) {
            let p = document.querySelector("p.active")
            // console.log([p]);
            //判断当前歌词距离顶部的距离
            if (p) {  //先进行判断，防止因为拿不到歌词报错
                if (p.offsetTop > 300) {
                    this.$refs.musicLyric.scrollTop=p.offsetTop-300
                }
            }
  }
```



###### 磁盘歌词的显示

1）进入歌曲详情页面是先显示磁盘

```
  //通过前面定义的布尔值变量来控制条件渲染
  <!-- 磁盘 -->
  <div class="detailContent" v-show="!isLyricShow">
  	....
  </div>

  <!-- 歌词 -->
  <div class="musicLyric" ref="musicLyric" v-show="isLyricShow">
	....
  </div>
```

2）点击磁盘中间的专辑图片之后就会显示歌词

```
 <!-- 磁盘 -->
  <div class="detailContent" v-show="!isLyricShow">
 	....
 	//给中间的专辑图片绑定点击事件，直接修改控制歌词显示与否的布尔值变量（取反即可）
    <img :src="musicList.al.picUrl" class="img_ar" @click="isLyricShow=true" ..>
  </div>
```

3）点击歌曲详情页的返回箭头退出该页面的时候，显示磁盘（保证后面再进入详情页首先展示的是磁盘，歌词需要手动点击）

```
//给详情页面顶部的左箭头绑定点击事件（在事件中修改控制歌词显示的布尔值变量）
 <div class="detailTopLeft">
        <svg class="icon" aria-hidden="true" @click="backHome">
            <use xlink:href="#icon-zuojiantou"></use>
        </svg>
        ....
 </div>
 
 
//点击返回按钮之后恢复到磁盘效果页面
backHome: function () {
   this.isLyricShow = false  //点击返回箭头就会显示磁盘，当再次点击底部进入奥歌曲详情页面的时候显示的是磁盘效果
   this.updateDetailShow()
},

```



##### 上下首切换

关键：修改vuex中的歌曲索引下标，通过控制下标-1还是+1来实现上一首和下一首的切换

1）在MusicDetail页面中获取vuex的歌曲列表playList、歌曲索引下标、以及更新下标的方法updatePlayListIndex

```
    computed: {
        ...mapState(['lyricList', 'currentTime','playListIndex','playList']),
        ...
    },
    methods: {
        ...mapMutations(['updateDetailShow', 'updatePlayListIndex']),
    }
    .....
```

2）给MusicDetail页面中上一首和下一首的从图标绑定切换的方法

直接定义一个修改的方法，通过给方法传递-1或者+1的参数，让参数和playListIndex相加得到新的播放歌曲的索引下标。

```
//icon图标绑定方法
//上一首
<svg class="icon" aria-hidden="true" @click="goPlay(-1)">
     <use xlink:href="#icon-shangyishou"></use>
</svg>

//下一首
<svg class="icon" aria-hidden="true" @click="goPlay(1)">
     <use xlink:href="#icon-xiayishou"></use>
</svg>
```

* 当前歌曲是第一首，在点击上一首的时候跳转到列表的最后一首
* 当前歌曲是最后一首，在点击下一首的时候跳转到列表的第一首

```
//methods中定义方法
		//点击播放上一首和下一首
        goPlay: function (num) {
            let index = this.playListIndex + num
            //传递index，传递下标
            //判断：第一首&&最后一首
            if (index < 0) {
                index=this.playList.length-1
            } else if (index == this.playList.length) {
                index=0
            }
            //更新下标
            this.updatePlayListIndex(index)
        },  
```



##### 进度条的显示

1）基本结构和样式

```
<div class="footerCenter">
<!-- 歌曲进度条 v-model双向绑定当前的歌曲进度 step表示移动的距离-->
	<input type="range" class="range" min="0" :max="duration" v-model="currentTime" step="0.05">
</div>
```

```
 .range{
      width: 100%;
      height: 0.6rem;
 }           
```

2）vuex中定义歌曲总时长（作为进度条的最大值max）

```
state:{
	...
	duration: 0,//歌曲的总时长（用于进度条的显示）
	...
},
mutations:{
	....
	//更新歌曲的总时长
    updateDuration: function (state, value) {
      state.duration = value
    },
    ....
}
```

3）FooterMusic中调用函数，传递audio中的歌词总时长

```
methods: {
        ...mapMutations(['updateIsbtnShow', 'updateDetailShow', 'updateCurrentTime', 'updateDuration']),
        ...
         //添加歌曲的总时长
        addDuration: function () {
            this.updateDuration(this.$refs.audio.duration)
        },
}
```

4）FooterMusic每次更新的时候也需要调用函数更新歌曲总时长（相当于换一首歌就要获取新歌的总时长）

```
updated() {
        this.$store.dispatch("getLyric", this.playList[this.playListIndex].id);
        this.updateDuration()
    },
```

5）FooterMusic给MusicDetail传递添加歌曲总时长的方法

```
 <van-popup v-model:show="detailShow" position="right" :style="{height:'100%', width:'100%'}">
        <MusicDetail :musicList="playList[playListIndex]" :play="play" :isbtnShow="isbtnShow" :addDuration="addDuration"/>
    </van-popup>
```

6）MusicDetail中接收调用

```
// 接收父组件传递过来的数据
props: ['musicList','isbtnShow','play','addDuration'],
....
//渲染 的时候就要调用函数获取总时长
mounted() {
    this.addDuration()
}
```

7）MusicDetail页面中监听当前时间和总时长对比，判断是否 需要切换到下一首歌曲

```
    watch: {
        currentTime: function (newValue) {
          	......
            //监听总时长,当总时长达到歌曲末尾的时候，自动切换到下一首歌曲
            if (newValue===this.duration) {
                //如果是最后一首就会自动切换到歌单的第一首
                if (this.playListIndex === this.playList.length - 1) {
                    this.updatePlayListIndex(0);
                    this.play()
                } else {
                    this.updatePlayListIndex(this.playListIndex + 1)
                }
            }
        }
    },
```





#### 首页搜索功能

##### 注册&跳转路由

1）views文件夹下新建Serach路由

2）新建之后需要在router/index.js路由配置文件中添加配置 

```
//搜索页面
  {
    path: '/search',
    name: 'Search',
    component: () => import(/* webpackChunkName: "Search" */ '../views/Search.vue')
  },
```

3）给首页的搜索按钮添加路由跳转事件

```
<svg class="topright icon" aria-hidden="true" @click="$router.push('/search')">
    <use xlink:href="#icon-sousuo"></use>
</svg>
```



##### 搭建搜索页面

###### 头部结构

```
//结构
<template>
  <div class="searchTop">
    <svg class=" icon" aria-hidden="true" @click="$router.go(-1)">
        <use xlink:href="#icon-zuojiantou"></use>
    </svg>
    <input type="text" placeholder="张杰">
  </div>
</template>
```

```
//样式
.searchTop{
    width: 100%;
    height: 1rem;
    padding: 0 .2rem;
    display: flex;
    align-items: center;
    input{
      margin-left: .2rem;
      border: none;
      border-bottom: 1px solid  #999;
      width: 90%;
      padding: .1rem;
      font-size: .35rem;
    }
  }
```

###### 搜索历史

1）基本结构

```
<div class="searchHistory">
    <span class="searchSpan">历史</span>
    <span v-for="item in keyWorldList" :key="item">{{item}}</span>
    <svg class=" icon" aria-hidden="true">
        <use xlink:href="#icon-shanchu"></use>
    </svg>
</div>

//在data中定义数组接收搜索关键词
data() {
    return {
      keyWorldList: [],
    }
  },
```

2）给输入框添加事件：按下enter之后就会将内容存储到关键词数组中

```
<input type="text" placeholder="张杰" v-model="searchKey" @keydown.enter="enterKey">

//data中定义变量和输入框双向绑定接收输入的内容
data() {
    return {
      searchKey: "",
    }
  },

//添加方法：按下enter之后就会添加历史记录
methods:{
	enterKey:function(){
		 this.keyWorldList.unshift(this.searchKey);
	}
}
```

3）搜索板块的样式

```
 .searchHistory{
    width: 100%;
    padding: .2rem;
    position: relative;
    display: flex;
    .searchSpan{
      font-weight: 700;
      font-size: .38rem;
      margin-right: .3rem;
    }
    .spanKey{
      width: 1.2rem;
      height: .6rem;
      line-height: .6rem;
      text-align: center;

      padding: 0.1rem, 0.2rem;
      background-color: #a7a7a7;
      border-radius: .4rem;
      margin: 0.1rem, 0.2rem;
      font-size: .34rem;
      margin-right: .2rem;
      display: inline-block;
    }
    .icon{
     width: .5rem;
     height: .5rem;
     position: absolute;
     right: .2rem;
    }
  }
```

4）搜索历史内存存入到sessionStorage中

```
//添加方法：按下enter之后就会添加历史记录
methods:{
	enterKey:function(){
		 this.keyWorldList.unshift(this.searchKey);
		 localStorage.setItem("keyWorldList", JSON.stringify(this.keyWorldList));
		 this.searchKey=""
	}
}
```

```
//初次渲染的时候查看本地存储中是否有数据
mounted(){
    //初次渲染的时候判断本地存储里面是否有数据
    this.keyWorldList=JSON.parse(localStorage.getItem('keyWorldList'))?JSON.parse(localStorage.getItem('keyWorldList')):[]
  },
```

5）删除历史记录

①删除图标绑定点击事件

```
<svg class=" icon" aria-hidden="true" @click="delHistory">
        <use xlink:href="#icon-shanchu"></use>
</svg>
```

②定义删除方法（搜索列表本身+sessionStorage里面的存储内容）

```
//删除历史记录
    delHistory: function () {
      localStorage.removeItem("keyWorldList")
      this.keyWorldList=[]
    },
```

6）优化：数组去重+限制搜索数量（超出限制数量的时候先搜索的不会展示出来）

```
   //添加历史记录
    enterKey:async function () {
      //判断当前搜索输入框中有无关键词
      if (this.searchKey !== "") {
        this.keyWorldList.unshift(this.searchKey);
         //数组元素去重
        this.keyWorldList = [...new Set(this.keyWorldList)];
        //固定长度
        //如果搜索的数组元素已经大于4，就会删除最前面搜索的
        if (this.keyWorldList.length > 4) {
          this.keyWorldList.splice(this.keyWorldList.length-1,1)
        }
        localStorage.setItem("keyWorldList", JSON.stringify(this.keyWorldList));
        //添加完毕之后清空搜索
        this.searchKey = "";
      }
    },
```

###### 搜索返回列表

1）request/api/home.js中封装api

```
//获取搜索
export function getSearchMusic(data) {
    return service({
        method: "GET",
        url: `/cloudsearch?keywords=${data}`
    })
}
```

2）Search页面中引入调用搜索api

```
import { getSearchMusic} from '@/request/api/home.js'
//data中定义数组接收搜索返回来的数据
 data() {
    return {
      ...
      searchList:[],//搜索返回来的数据
    }
  },
 methods:{
 	 //添加历史记录
    enterKey:async function () {
 		...
 		//获取接收搜索返回来的数据
        let res = await getSearchMusic(this.searchKey);
        // console.log(res);
        this.searchList = res.data.result.songs;


        //添加完毕之后清空搜索
        this.searchKey = "";
      }
    },
 }
```

3）点击搜索的历史记录也能返回搜索列表数据

```
//给每一个item绑定点击事件 
<div class="searchHistory">
    ....
    <span v-for="item in keyWorldList" :key="item" class="spanKey" @click="searchHistory(item)">
      {{item}}
    </span>
	....
  </div>
  
methods:{
	//点击历史记录也会显示搜索出来的内容
    searchHistory:async function (item) {
      let res = await getSearchMusic(item);
      // console.log(res);
      this.searchList = res.data.result.songs;
    },
}
```

###### 渲染搜索列表

和前面歌单歌曲列表基本一致，copy过来修改数据

```
  <!-- 搜索出来的列表数据 -->
  <div class="itemList" v-for="(item,i) in searchList" :key="i"  >
            <div class="listLeft" @click="updateIndex(item)">
                <span class="index" v-if="i<9">0{{i+1}}</span>
                <span class="index" v-else>{{i+1}}</span>

                <div class="content">
                    <p>{{ item.name }}</p>
                    <span v-for="(ar,index) in item.ar" :key="index">
                        <!-- 如果有多个歌手，需要遍历 -->
                        {{ar.name}}&nbsp
                    </span>
                </div>
            </div>
           
            <div class="listRight">
                <!-- 有mv就渲染mv的字体图标 -->
                <svg class="icon" aria-hidden="true" v-if="item.mv!= 0">
                    <use xlink:href="#icon-bofangMV"></use>
                </svg>
                <svg class="icon liebiao" aria-hidden="true">
                    <use xlink:href="#icon-31liebiao"></use>
                </svg>
            </div>
  </div>
```

###### 点击播放

点击某一首歌曲的时候，不需要添加一整个列表只需要将当前点击的这首添加到播放列表并且播放即可

1）vuex中定义方法

```
mutations:{
	//搜索添加目前歌曲
    pushPlayList: function (state, value) {
      state.playList.push(value)
    },
}
```

2）Search页面中定义调用方法

```
//点击之后添加当前歌曲进入到列表
    updateIndex: function (item) {
      // item.al = item.album;
      // item.al.picUrl=item.album.artist.imglvlUrl
      this.$store.commit("pushPlayList", item),
      this.$store.commit("updatePlayListIndex",this.$store.state.playList.length-1)
    }
```

